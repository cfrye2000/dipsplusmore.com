<?php
// Generated automatically by daogen.
// Do NOT edit this file.
// Any changes made to this file will be overwritten the next time it is generated.

if (!class_exists('Category')) include dirname(__FILE__).'/Category.class.php';

class CategoryDAO {
	public static $ALLOWED_QUERY_OPERATORS = array('=', '<', '<=', '>', '>=', 'beginsWith', 'contains', 'endsWith');
	public static $ALLOWED_NUMERIC_QUERY_OPERATORS = array('=', '<', '<=', '>', '>=');
	public static $ALLOWED_STRING_QUERY_OPERATORS = array('=', '<', '<=', '>', '>=', 'beginsWith', 'contains', 'endsWith');
	protected $connection;

	public function CategoryDAO($connection) {
		$this->connection = $connection;
	}

	public function insert($category) {
		$ps = new PreparedStatement("insert into category (name, description, isvisible) values (?, ?, ?)");
		$ps->setString($category->name);
		$ps->setString($category->description);
		$ps->setInt($category->isvisible);
		$this->connection->executeUpdate($ps);
		$category->id = $this->connection->getLastInsertId();
	}

	public function update($category) {
		$ps = new PreparedStatement("update category set name = ?, description = ?, isvisible = ? where id = ?");
		$ps->setString($category->name);
		$ps->setString($category->description);
		$ps->setInt($category->isvisible);
		$ps->setInt($category->id);
		$this->connection->executeUpdate($ps);
	}

	public function delete($id) {
		$ps = new PreparedStatement("delete from category where id = ?");
		$ps->setInt($id);
		$this->connection->executeUpdate($ps);
	}

	public function load($id) {
		$ps = new PreparedStatement("select * from category where id = ?");
		$ps->setInt($id);
		$arr = $this->connection->fetchArray($this->connection->executeQuery($ps), true);
		if ($arr === false) return false;
		$category = new Category();
		$category->loadFromArray($arr);
		return $category;
	}

	public function findByIdPS($id, $queryOperator = '=', $orderBy = null, $offset = 0, $limit = 0) {
		if (!in_array($queryOperator, CategoryDAO::$ALLOWED_NUMERIC_QUERY_OPERATORS)) $queryOperator = CategoryDAO::$ALLOWED_NUMERIC_QUERY_OPERATORS[0];
		$ps = new PreparedStatement("select * from category where id $queryOperator ?".((($orderBy!==null)&&($orderBy!='')) ? (' order by '.$orderBy) : ''), $offset, $limit);
		$ps->setInt($id);
		return $ps;
	}

	public function findById($id, $queryOperator = '=', $orderBy = null, $offset = 0, $limit = 0) {
		return $this->findWithPreparedStatement($this->findByIdPS($id, $queryOperator, $orderBy, $offset, $limit));
	}

	public function findByNamePS($name, $queryOperator = '=', $orderBy = null, $offset = 0, $limit = 0) {
		if (!in_array($queryOperator, CategoryDAO::$ALLOWED_STRING_QUERY_OPERATORS)) $queryOperator = CategoryDAO::$ALLOWED_STRING_QUERY_OPERATORS[0];
		$sqlQueryOperator = (($queryOperator == 'beginsWith') || ($queryOperator == 'endsWith') || ($queryOperator == 'contains')) ? 'like' : $queryOperator;
		$ps = new PreparedStatement("select * from category where name $sqlQueryOperator ?".((($orderBy!==null)&&($orderBy!='')) ? (' order by '.$orderBy) : ''), $offset, $limit);
		if ($queryOperator == 'beginsWith') {
			$ps->setString($name.'%');
		} else if ($queryOperator == 'endsWith') {
			$ps->setString('%'.$name);
		} else if ($queryOperator == 'contains') {
			$ps->setString('%'.$name.'%');
		} else {
			$ps->setString($name);
		}
		return $ps;
	}

	public function findByName($name, $queryOperator = '=', $orderBy = null, $offset = 0, $limit = 0) {
		return $this->findWithPreparedStatement($this->findByNamePS($name, $queryOperator, $orderBy, $offset, $limit));
	}

	public function findByDescriptionPS($description, $queryOperator = '=', $orderBy = null, $offset = 0, $limit = 0) {
		if (!in_array($queryOperator, CategoryDAO::$ALLOWED_STRING_QUERY_OPERATORS)) $queryOperator = CategoryDAO::$ALLOWED_STRING_QUERY_OPERATORS[0];
		$sqlQueryOperator = (($queryOperator == 'beginsWith') || ($queryOperator == 'endsWith') || ($queryOperator == 'contains')) ? 'like' : $queryOperator;
		$ps = new PreparedStatement("select * from category where description $sqlQueryOperator ?".((($orderBy!==null)&&($orderBy!='')) ? (' order by '.$orderBy) : ''), $offset, $limit);
		if ($queryOperator == 'beginsWith') {
			$ps->setString($description.'%');
		} else if ($queryOperator == 'endsWith') {
			$ps->setString('%'.$description);
		} else if ($queryOperator == 'contains') {
			$ps->setString('%'.$description.'%');
		} else {
			$ps->setString($description);
		}
		return $ps;
	}

	public function findByDescription($description, $queryOperator = '=', $orderBy = null, $offset = 0, $limit = 0) {
		return $this->findWithPreparedStatement($this->findByDescriptionPS($description, $queryOperator, $orderBy, $offset, $limit));
	}

	public function findByIsvisiblePS($isvisible, $queryOperator = '=', $orderBy = null, $offset = 0, $limit = 0) {
		if (!in_array($queryOperator, CategoryDAO::$ALLOWED_NUMERIC_QUERY_OPERATORS)) $queryOperator = CategoryDAO::$ALLOWED_NUMERIC_QUERY_OPERATORS[0];
		$ps = new PreparedStatement("select * from category where isvisible $queryOperator ?".((($orderBy!==null)&&($orderBy!='')) ? (' order by '.$orderBy) : ''), $offset, $limit);
		$ps->setInt($isvisible);
		return $ps;
	}

	public function findByIsvisible($isvisible, $queryOperator = '=', $orderBy = null, $offset = 0, $limit = 0) {
		return $this->findWithPreparedStatement($this->findByIsvisiblePS($isvisible, $queryOperator, $orderBy, $offset, $limit));
	}

	public function findAllPS($orderBy = null, $offset = 0, $limit = 0) {
		$ps = new PreparedStatement("select * from category".((($orderBy!==null)&&($orderBy!='')) ? (' order by '.$orderBy) : ''), $offset, $limit);
		return $ps;
	}

	public function findAll($orderBy = null, $offset = 0, $limit = 0) {
		return $this->findWithPreparedStatement($this->findAllPS($orderBy, $offset, $limit));
	}

	public function findWithPreparedStatement($ps) {
		return CategoryDAO::loadAllFromResultSet($this->connection, $this->connection->executeQuery($ps), true);
	}

	public static function loadAllFromResultSet($connection, $rs, $freeResultBeforeReturn = false) {
		$rows = array();
		while ($arr = $connection->fetchArray($rs)) {
			$category = new Category();
			$category->loadFromArray($arr);
			$rows[] = $category;
		}
		if ($freeResultBeforeReturn) $connection->freeResult($rs);
		return $rows;
	}
}
